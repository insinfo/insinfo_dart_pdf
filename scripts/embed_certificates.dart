import 'dart:io';
import 'dart:convert';

void main() async {
  await generate(
    'assets/truststore/cadeia_icp_brasil',
    'lib/src/security/chain/generated/icp_brasil_trust_store.dart',
    'icpBrasilTrustStore',
    'ICP-Brasil Root Certificates',
  );

  await generate(
    'assets/truststore/serpro',
    'lib/src/security/chain/generated/serpro_trust_store.dart',
    'serproTrustStore',
    'Serpro Root Certificates',
  );

  await generate(
    'assets/truststore/iti',
    'lib/src/security/chain/generated/iti_trust_store.dart',
    'itiTrustStore',
    'ITI Root Certificates',
  );

  await generate(
    'assets/truststore/gov.br',
    'lib/src/security/chain/generated/govbr_trust_store.dart',
    'govBrTrustStore',
    'Gov.br Root Certificates',
  );
}

Future<void> generate(
  String sourceDir,
  String outputPath,
  String varName,
  String description,
) async {
  final dir = Directory(sourceDir);
  if (!dir.existsSync()) {
    print('Directory not found: ${dir.path}');
    return;
  }

  final files = dir
      .listSync(recursive: true)
      .whereType<File>()
      .where((f) {
        final lower = f.path.toLowerCase();
        return lower.endsWith('.crt') ||
            lower.endsWith('.pem') ||
            lower.endsWith('.cer');
      })
      .toList()
    ..sort((a, b) => a.path.compareTo(b.path));
  final StringBuffer buffer = StringBuffer();

  buffer.writeln("/// $description embedded for AOT/Wasm support");
  buffer.writeln("/// Generated by scripts/embed_certificates.dart");
  buffer.writeln("");
  buffer.writeln("const List<String> $varName = [");

  int count = 0;
  final Set<String> seen = <String>{};
  for (final file in files) {
    try {
      final bytes = await file.readAsBytes();
      final List<String> pemBlocks = _readAsPemBlocks(bytes);
      for (final pem in pemBlocks) {
        final normalized = pem.replaceAll('\r\n', '\n').trim();
        if (!seen.add(normalized)) {
          continue;
        }
        final escaped = normalized.replaceAll('\n', '\\n');
        buffer.writeln("  '$escaped',");
        count++;
      }
    } catch (e) {
      print('Skipping ${file.path}: $e');
    }
  }

  buffer.writeln("];");
  
  final outFile = File(outputPath);
  if (!outFile.parent.existsSync()) {
    outFile.parent.createSync(recursive: true);
  }
  outFile.writeAsStringSync(buffer.toString());
  print('Generated $outputPath with $count certificates.');
}

List<String> _readAsPemBlocks(List<int> bytes) {
  // Try to parse as PEM first.
  try {
    final content = utf8.decode(bytes);
    if (content.contains('-----BEGIN CERTIFICATE-----')) {
      final normalized = content.replaceAll('\r\n', '\n');
      final blocks = _extractPemCertificates(normalized);
      if (blocks.isNotEmpty) {
        return blocks;
      }
    }
  } catch (_) {
    // Not UTF-8 PEM; fall through to DER.
  }

  // Assume DER and convert to PEM.
  final base64 = base64Encode(bytes);
  return <String>[
    '-----BEGIN CERTIFICATE-----\n$base64\n-----END CERTIFICATE-----',
  ];
}

List<String> _extractPemCertificates(String pemText) {
  final regExp = RegExp(
    r'-----BEGIN CERTIFICATE-----[\s\S]*?-----END CERTIFICATE-----',
    multiLine: true,
  );
  final matches = regExp.allMatches(pemText).toList(growable: false);
  if (matches.isEmpty) return const <String>[];

  return matches
      .map((m) => pemText.substring(m.start, m.end).trim())
      .where((s) => s.isNotEmpty)
      .toList(growable: false);
}
